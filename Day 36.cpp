//=======================================================================================================
//                                                                                                      =
//................................................. lambda using ..... ................................=
//                                                                                                      =
//=======================================================================================================
#include <iostream>
using namespace std;
//==================================
//.................................
//==================================

//capture list 
// the values that are stored in [] of lambda function 
// this is only done by
// int a =1 
// int b = 2
// then you yan simply add those parameters to 
// as
// [ a , b ](){
//     // body of function
//  }
// it can only use the things that are in lambda function


//==================================
//.................................
//==================================

// we can also pass by refence as then we have the same address of value that is outside of 
// function
// [ & c {
//     // body of function
//  }
// it can only use the things that are in lambda function

//==================================
//.................................
//==================================


// if you want to use everything in lambda function inside the code 
// of lambda then you oonly have to put equal sign 

// [ = ]() {
//   ///body
//  };

//==================================
//.................................
//==================================


// if you put only and sign in your lambda function then 
// you will access every variable by refrence

//
// [ & ]() {
//   ///body
//  };
//=======================================================================================================
//                                                                                                      =
//...............................................>> Function Tamplet  ..................................=
//                                                                                                      =
//=======================================================================================================
  


//  template < type_name >
//   t maximun (t a ,t b) {
// 
//    return (a>b) ? a : b ;
//
//    }

/*

Function templates are just blueprints. They're not real C++ code
consumed by the compiler. The compiler generates real C++ code
by looking at the arguments you call your function template with
All
From
The real C++ function generated by the compiler is called a
template instance
ZERO
A template instance will be reused when a similar function call
(argument types) is issued. No duplicates are generated by the
Compiler

*/

template < typename T >
T maximum(T a, T b) {
	
	    return (a>b) ? a : b ;
	
	    }
int main()
{

	// pass by value
   int num = 10;
   auto modifyValue = [num]() {  
	      cout<< num ; };  // num captured by value

   modifyValue();  // Works, but doesn't modify the original num

   std::cout << "Original num: " << num << std::endl;  // Output: Original num: 10

   //================================================
   // pass by refrence 
   int count = 0;
   auto incrementer = [&count]() { count++; };  // Capture count by reference
   incrementer();                                // Modifies the original count
   cout << count << std::endl;              // Output: 1


   // capture all values using refrence 

   int a = 5, b = 10;
   int c, d;
   auto lambda4 = [&]() {
	   a *= 3;  // Modifies the original a and b
	   b -= 2;
	   };

   // capture using value 
   auto lambda5 = [ = ]() {
	   cout << c;
	   };

   //use of template.........
   
   int u{ 2 };
   int w{ 3 };
   
   int result = maximum(u, w);
    
   cout << " the result of tamplete is gien as :   " << result<< endl;

   

   // when we are using pointer in this code we will compare the address of b
   //both variables and give resut by comparint both of them
   int* p1{ &u };
   int* p2{ &w };

   auto result1 = maximum(p1, p2);

   cout << " the result of tamplete is gien as :   " << result1 << endl;

   // ccpinsight.io is a tool that is used for checking the working oof template function
}
